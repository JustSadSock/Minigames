<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <meta name="theme-color" content="#0d0f17" id="themeColor">
  <title>DeepFly — мини‑игры</title>
  <!--
    Это стартовая страница игрового хаба.  Она не требует сборки или внешних
    библиотек и может быть открыта напрямую из файловой системы.  Основная
    логика написана внизу в виде ES‑модуля.  Игры подключаются динамически
    через ссылку вида #game=&lt;slug&gt; и располагаются в папке games/.
  -->
  <style>
    :root{
      /* Базовая цветовая палитра.  Все переменные легко
         перекрашиваются — достаточно сменить значения здесь. */
      --bg:#0d0f17;
      --panel:#111422;
      --grid-even:#1a1d2c;
      --grid-odd:#171a29;
      --border:#1b1e2e;
      --highlight:#272a3b;
      --ink:#d7defd;
      --muted:#8c92b8;
      --p1:#ff5ca8;
      --p2:#68c7ff;
      --radius:12px;
      --shadow:0 8px 24px rgba(0,0,0,.35);
    }

    html,body{height:100%;margin:0;color:var(--ink);background:var(--bg);
      font-family:ui-monospace,SFMono-Regular,Consolas,"Liberation Mono",monospace;
      overscroll-behavior:none;}
    *{box-sizing:border-box;}
    body{display:flex;flex-direction:column;overflow:hidden;touch-action:manipulation;}
    header,footer{
      padding:8px 16px;
      background:var(--panel);
      border-bottom:1px solid var(--border);
      color:var(--ink);
      display:flex;align-items:center;gap:16px;
    }
    header h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.5px;}
    header .spacer{flex:1;}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    /* Кнопки с четырьмя состояниями: idle, hover, active, disabled */
    .btn{
      --bg1: #222642;
      --bg2: #191c30;
      --border1: #2a2e49;
      --border2: #191c30;
      --text: #e6ebff;
      appearance:none;border:0;cursor:pointer;
      padding:6px 10px;font-weight:700;font-size:12px;border-radius:10px;
      color:var(--text);
      background:
        linear-gradient(180deg, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      box-shadow: inset 0 -2px 0 0 rgba(0,0,0,.4), 0 6px 0 0 rgba(0,0,0,.2), 0 10px 16px rgba(0,0,0,.3);
      transition: transform .05s ease, filter .15s ease;
      position:relative;
      min-width:44px;min-height:44px;touch-action:manipulation;
    }
    .btn::after{
      content:""; position:absolute; inset:0;border-radius:10px;
      box-shadow: inset 0 0 0 1px var(--border1), inset 0 0 0 2px var(--border2);
      pointer-events:none;
    }
    .btn:hover{filter:saturate(1.3);}
    .btn:active{transform:translateY(2px); box-shadow: inset 0 -1px 0 0 rgba(0,0,0,.45), 0 4px 0 0 rgba(0,0,0,.2), 0 8px 12px rgba(0,0,0,.3);}
    .btn[disabled]{opacity:.5;cursor:not-allowed;filter:grayscale(.6) saturate(.5);}
    .btn:focus{outline:2px solid var(--highlight);outline-offset:2px;}
    .p1{--bg1:#ff6bb5;--bg2:#c43e7a;--text:#fff;}
    .p2{--bg1:#7ad6ff;--bg2:#2a97d8;--text:#fff;}
    .ghost{--bg1:#1a1d31;--bg2:#0f1223;--text:#aeb6e9;}

    main{flex:1;display:grid;grid-template-columns:1fr minmax(260px,72vh) 1fr;gap:16px;padding:16px;align-items:flex-start;}
    .side{display:grid;gap:16px;max-width:380px;width:100%;}
    .center{display:grid;gap:16px;}
    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:12px;
      box-shadow:var(--shadow);
    }
    .avatar{display:grid;grid-template-columns:auto 1fr;gap:12px;align-items:center;}
    .avatar .name{font-weight:700;color:#e9edff;font-size:14px;margin-bottom:4px;}
    .avatar .stats{font-size:12px;color:var(--muted);}    
    .pixel{image-rendering: pixelated; image-rendering: crisp-edges;}
    /* Сцена-превью */
    .scene{
      position:relative;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;aspect-ratio:1/1;
    }
    .scene canvas{border-radius:var(--radius);}
    /* Горизонтальный список игр */
    .cards{display:grid;grid-auto-flow:column;grid-auto-columns:clamp(240px,38vw,360px);overflow-x:auto;scroll-snap-type:x mandatory;gap:16px;padding:8px 0;}
    .card{scroll-snap-align:start;appearance:none;border:0;cursor:pointer;background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);color:var(--ink);font-weight:700;font-size:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;transition:transform .05s ease,filter .15s ease;touch-action:manipulation;min-width:44px;min-height:44px;}
    .card .icon{font-size:32px;line-height:1;}
    .card:hover{filter:saturate(1.2);}
    .card:active{transform:translateY(2px);}
    .card:focus{outline:2px solid var(--highlight);outline-offset:2px;}
    .hud{display:flex;justify-content:space-between;gap:8px;font-size:12px;color:var(--muted);}
    .tag{padding:4px 8px;border-radius:999px;background:#14172a;border:1px solid #232742;}
    @media(max-width:860px){
      main{grid-template-columns:1fr;grid-template-rows:auto auto auto;max-width:720px;margin:0 auto;}
      .side{max-width:none;}
    }

    .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:1000;}
    .dialog{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:16px;box-shadow:var(--shadow);}
    .hidden{display:none;}
  </style>
</head>
<body>
  <header>
    <h1>DeepFly — мини‑игры</h1>
    <div class="spacer"></div>
    <div class="row">
      <button class="btn ghost" id="themeToggle">Тема</button>
      <button class="btn ghost" id="openGames">Игры</button>
      <button class="btn ghost" id="openSettings">Настройки</button>
      <button class="btn ghost" id="openAvatar">Аватар</button>
    </div>
  </header>

  <main>
    <!-- Левая колонка: профиль и настройки -->
    <section class="side">
      <div class="panel avatar">
        <canvas id="avatar1" class="pixel" width="64" height="64" style="width:64px;height:64px;"></canvas>
        <div>
          <div class="name" id="playerName">Игрок</div>
          <div class="stats" id="playerStats">готов • ♥ 3 • ★ 0</div>
          <div class="row" style="margin-top:8px">
            <button class="btn p1" id="profileSave">Сохранить</button>
            <button class="btn ghost" id="profileReset">Сброс</button>
          </div>
        </div>
      </div>
    </section>
    <!-- Центральная колонка: сцена и меню игр -->
    <section class="center">
      <div class="scene panel" id="scenePanel">
        <canvas id="preview" class="pixel" width="192" height="192"></canvas>
      </div>
      <div id="menu" class="cards panel"></div>
    </section>
    <!-- Правая колонка: информация и HUD -->
    <section class="side">
      <div class="panel avatar">
        <canvas id="avatar2" class="pixel" width="64" height="64" style="width:64px;height:64px;"></canvas>
        <div>
          <div class="name" id="player2Name">Гость</div>
          <div class="stats" id="player2Stats">в сети • ♥ 3 • ★ 0</div>
          <div class="row" style="margin-top:8px">
            <button class="btn p2" id="inviteBtn">Пригласить</button>
            <button class="btn ghost" id="skinBtn">Скин</button>
          </div>
        </div>
      </div>
      <div class="panel hud">
        <span class="tag">v1.0.0</span>
        <span class="fps" id="fps">FPS –</span>
      </div>
    </section>
  </main>
  <footer>
    <small style="color:var(--muted)">Навигация: выбирайте игру в меню или используйте хэш <code>#game=&lt;slug&gt;</code> в адресной строке.</small>
  </footer>

  <div id="settingsDialog" class="backdrop hidden">
    <div id="settingsPanel" class="dialog" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <button class="btn ghost" id="settingsClose" aria-label="Закрыть" style="position:absolute;top:8px;right:8px">×</button>
      <h2 id="settingsTitle">Настройки</h2>
      <label><input type="checkbox" id="muteToggle"> Звук</label><br>
      <label><input type="checkbox" id="vfxToggle"> Эффекты</label><br>
      <label><input type="checkbox" id="themeAltToggle"> Альт. тема</label><br>
      <div class="row" style="margin-top:8px;">
        <button class="btn p1" id="settingsSave">Сохранить</button>
        <button class="btn ghost" id="settingsCancel">Отмена</button>
      </div>
    </div>
  </div>

  <div id="avatarDialog" class="backdrop hidden">
    <div id="avatarPanel" class="dialog" role="dialog" aria-modal="true" aria-labelledby="avatarTitle">
      <button class="btn ghost" id="avatarClose" aria-label="Закрыть" style="position:absolute;top:8px;right:8px">×</button>
      <h2 id="avatarTitle">Профиль</h2>
      <input id="nickInput" style="font-size:16px;padding:4px;width:100%;margin-bottom:8px;" />
      <canvas id="avatarEdit" class="pixel" width="64" height="64" style="width:64px;height:64px;margin-bottom:8px;"></canvas>
      <div class="row">
        <button class="btn ghost" id="avatarPrev">◀</button>
        <button class="btn ghost" id="avatarNext">▶</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button class="btn p1" id="avatarSave">Сохранить</button>
        <button class="btn ghost" id="avatarCancel">Отмена</button>
      </div>
    </div>
  </div>

  <script type="module">
  /*
    Базовый SPA‑хаб: рисует превью (сетку, курсор, частицы), управляет темой,
    хранит настройки, загружает игровые модули и передаёт им контекст.
    Каждая игра экспортирует manifest + mount/unmount, живёт в games/<slug>/.
  */
  const HUB_VERSION = '1.0.0';

  const $ = (sel) => document.querySelector(sel);

  // Простая тема: dark и alternative
  const theme = {
    current: 'dark',
    apply(name){
      theme.current = name;
      if(name === 'alt'){
        document.documentElement.style.setProperty('--bg','#141b2e');
        document.documentElement.style.setProperty('--panel','#1c233c');
        document.documentElement.style.setProperty('--grid-even','#202745');
        document.documentElement.style.setProperty('--grid-odd','#1d2341');
        document.documentElement.style.setProperty('--border','#252e50');
        document.documentElement.style.setProperty('--ink','#ccd9ff');
        document.documentElement.style.setProperty('--muted','#8fa1c7');
      } else {
        document.documentElement.style.setProperty('--bg','#0d0f17');
        document.documentElement.style.setProperty('--panel','#111422');
        document.documentElement.style.setProperty('--grid-even','#1a1d2c');
        document.documentElement.style.setProperty('--grid-odd','#171a29');
        document.documentElement.style.setProperty('--border','#1b1e2e');
        document.documentElement.style.setProperty('--ink','#d7defd');
        document.documentElement.style.setProperty('--muted','#8c92b8');
      }
      const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
      document.getElementById('themeColor').setAttribute('content', bg);
    },
    toggle(){ const next = theme.current==='dark' ? 'alt' : 'dark'; theme.apply(next); return next; }
  };
  $('#themeToggle').onclick = () => { const t = theme.toggle(); settings.theme = t; store.set('settings.theme', t); $('#themeAltToggle').checked = (t==='alt'); };

  // Примитивный шина событий
  const bus = new EventTarget();

  // хранилище настроек/прогресса (IndexedDB можно добавить позже)
  const store = {
    prefix:'deepfly.',
    get(key, def){ try{ const v = localStorage.getItem(this.prefix+key); return v ? JSON.parse(v) : def; }catch(_){ return def; } },
    set(key,val){ localStorage.setItem(this.prefix+key, JSON.stringify(val)); },
    del(key){ localStorage.removeItem(this.prefix+key); }
  };

  const settings = { mute:false, vfx:true, theme:'dark' };

  // Мини‑тост
  function flash(text){
    const el = document.createElement('div');
    el.textContent = text;
    el.style.cssText = `position:fixed;left:50%;top:20px;transform:translateX(-50%);background:#1e2244;border:1px solid #2c325a;color:#e6ebff;padding:8px 12px;border-radius:10px;box-shadow:${getComputedStyle(document.documentElement).getPropertyValue('--shadow')};font-size:12px;z-index:999;opacity:0;transition:opacity .2s ease`;
    document.body.appendChild(el);
    requestAnimationFrame(()=>{ el.style.opacity='1'; });
    setTimeout(()=>{ el.style.opacity='0'; }, 2200);
    setTimeout(()=>{ el.remove(); }, 2600);
  }

  function openDialog(sel, opener){
    const wrap = typeof sel==='string'?$(sel):sel;
    const prev = opener || document.activeElement;
    wrap.classList.remove('hidden');
    const focusable = Array.from(wrap.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])')).filter(el=>!el.disabled);
    const first = focusable[0];
    const last = focusable[focusable.length-1];
    if(first) first.focus();
    const inertEls = Array.from(document.body.children).filter(el=>el!==wrap);
    inertEls.forEach(el=>el.inert=true);
    function onKey(e){
      if(e.key==='Escape'){ close(); }
      else if(e.key==='Tab'){
        if(focusable.length===0){ e.preventDefault(); return; }
        if(e.shiftKey){
          if(document.activeElement===first){ last.focus(); e.preventDefault(); }
        }else{
          if(document.activeElement===last){ first.focus(); e.preventDefault(); }
        }
      }
    }
    function onClick(e){ if(e.target===wrap){ close(); } }
    function close(){
      wrap.classList.add('hidden');
      document.removeEventListener('keydown',onKey);
      wrap.removeEventListener('click',onClick);
      inertEls.forEach(el=>el.inert=false);
      prev && prev.focus();
    }
    document.addEventListener('keydown',onKey);
    wrap.addEventListener('click',onClick);
    return { close };
  }

  // Автономный мини‑превью на главной (сеточная арена, курсоры, частицы)
  const previewCanvas = $('#preview');
  const pctx = previewCanvas.getContext('2d', { alpha:false });
  pctx.imageSmoothingEnabled = false;
  function fitCanvas(canvas, panel){
    const ro = new ResizeObserver(()=>{
      const w = panel.clientWidth; const h = panel.clientHeight;
      const scale = Math.max(1, Math.floor(Math.min(w/canvas.width, h/canvas.height)));
      canvas.style.width = canvas.width*scale+'px';
      canvas.style.height = canvas.height*scale+'px';
    });
    ro.observe(panel); return ro;
  }
  const previewRO = fitCanvas(previewCanvas, $('#scenePanel'));
  const PREVIEW_W = 192, PREVIEW_H = 192;
  const GRID = 12;
  const previewState = {
    t:0,
    cursors:[
      { x: Math.floor(GRID*0.7), y: Math.floor(GRID*0.4), frame:0, color: '#ff77bd' },
      { x: Math.floor(GRID*0.3), y: Math.floor(GRID*0.7), frame:0, color: '#68c7ff' }
    ],
    particles:[]
  };
  function rnd(n){ return Math.random()*n; }
  function spawn(x,y,color){
    if(!settings.vfx) return;
    for(let i=0;i<5;i++){
      previewState.particles.push({ x, y, vx:(Math.random()-.5)*.6, vy:(Math.random()-.5)*.6 - .2, life:20+Math.random()*20, age:0, color });
    }
  }
  previewCanvas.addEventListener('pointerdown', e=>{
    const rect = previewCanvas.getBoundingClientRect();
    const sx = (e.clientX-rect.left)/rect.width;
    const sy = (e.clientY-rect.top)/rect.height;
    const gx = Math.max(0, Math.min(GRID-1, Math.floor(sx*GRID)));
    const gy = Math.max(0, Math.min(GRID-1, Math.floor(sy*GRID)));
    previewState.cursors[0].x = gx; previewState.cursors[0].y = gy; previewState.cursors[0].frame = 0;
    spawn(gx*16+8, gy*16+8, '#ff77bd');
  });
  function drawPreviewGrid(){
    const styles = getComputedStyle(document.documentElement);
    const even = styles.getPropertyValue('--grid-even');
    const odd = styles.getPropertyValue('--grid-odd');
    const border = styles.getPropertyValue('--border');
    for(let y=0;y<GRID;y++){
      for(let x=0;x<GRID;x++){
        pctx.fillStyle = (x+y)%2 ? even : odd;
        pctx.fillRect(x*16,y*16,16,16);
      }
    }
    pctx.strokeStyle = border;
    pctx.lineWidth = 1;
    pctx.strokeRect(0.5,0.5,PREVIEW_W-1,PREVIEW_H-1);
  }
  function drawPreviewCursor(c){
    const frames = [2,3,4,5];
    const r = frames[Math.floor(c.frame)%frames.length];
    const cx = c.x*16+8; const cy = c.y*16+8;
    pctx.strokeStyle = c.color; pctx.lineWidth = 1;
    pctx.beginPath(); pctx.arc(cx, cy, r, 0, Math.PI*2); pctx.stroke();
    pctx.beginPath(); pctx.arc(cx, cy, Math.max(1,r-2), 0, Math.PI*2); pctx.stroke();
  }
  function drawPreviewParticles(){
    for(let i=previewState.particles.length-1;i>=0;i--){
      const p = previewState.particles[i]; p.age++;
      p.x += p.vx; p.y += p.vy; p.vy += 0.02;
      const a = Math.max(0, 1 - p.age/p.life);
      if(p.age>p.life){ previewState.particles.splice(i,1); continue; }
      pctx.fillStyle = p.color; pctx.globalAlpha = a;
      pctx.fillRect(p.x-1,p.y-1,2,2);
      pctx.globalAlpha = 1;
    }
  }
  let fpsCounter=0, fpsLast=performance.now();
  let previewRAF=null, previewRunning=false;
  function previewFrame(){
    const now = performance.now(); fpsCounter++;
    if(now - fpsLast > 500){
      const fps = Math.round(fpsCounter*1000/(now-fpsLast));
      $('#fps').textContent = `FPS ${fps}`;
      fpsCounter=0; fpsLast = now;
    }
    previewState.t++;
    drawPreviewGrid();
    previewState.cursors.forEach(c => { c.frame += 0.25; drawPreviewCursor(c); });
    if(previewState.t % 12 === 0){
      previewState.cursors.forEach(c => spawn(c.x*16+8, c.y*16+8, c.color));
    }
    drawPreviewParticles();
    previewRAF = requestAnimationFrame(previewFrame);
  }
  function startPreview(){ if(previewRunning) return; previewRunning=true; previewFrame(); }
  function stopPreview(){ if(!previewRunning) return; previewRunning=false; if(previewRAF!==null){ cancelAnimationFrame(previewRAF); previewRAF=null; } }
  drawPreviewGrid(); startPreview();

  // Примитивные аватары с лёгким движением глаз
  function makeAvatar(canvas, tint = '#ff5ca8'){
    const ac = canvas.getContext('2d'); ac.imageSmoothingEnabled = false;
    const W=16, H=16, SCALE=4;
    let currentTint = tint;
    let tick=0; let pointer=0;
    function onMove(e){
      if(!settings.vfx){ pointer=0; return; }
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX-rect.left)/rect.width - 0.5;
      pointer = Math.max(-1, Math.min(1, Math.round(sx*2)));
    }
    canvas.addEventListener('pointermove', onMove);
    function step(){
      tick++;
      let eyeDx = 0;
      if(settings.vfx){ eyeDx = Math.round(Math.sin(tick/40)) + pointer; eyeDx = Math.max(-1, Math.min(1, eyeDx)); }
      else pointer=0;
      drawSprite(ac,W,H,SCALE,currentTint,0,0,eyeDx);
      requestAnimationFrame(step);
    }
    step();
    return { setTint(c){ currentTint = c; }, destroy(){ canvas.removeEventListener('pointermove', onMove); } };
  }
  function px(ctx,x,y,s,color){ ctx.fillStyle=color; ctx.fillRect(x*s,y*s,s,s); }
  function drawSprite(ctx,W,H,S,tint,dx,dy,eyeDx){
    const skin='#f4d7b5'; const hair=tint; const shirt='#2a2f54'; const eye='#10131e';
    ctx.clearRect(0,0,W*S,H*S);
    px(ctx,7+dx,12+dy,S,shirt); px(ctx,8+dx,12+dy,S,shirt);
    px(ctx,7+dx,11+dy,S,shirt); px(ctx,8+dx,11+dy,S,shirt);
    for(let i=5;i<=10;i++) px(ctx,i+dx,7+dy,S,skin);
    for(let i=6;i<=9;i++) px(ctx,i+dx,6+dy,S,skin);
    for(let i=5;i<=10;i++) px(ctx,i+dx,5+dy,S,hair);
    px(ctx,5+dx,6+dy,S,hair); px(ctx,10+dx,6+dy,S,hair);
    px(ctx,6+dx+eyeDx,7+dy,S,eye); px(ctx,9+dx+eyeDx,7+dy,S,eye);
    ctx.globalAlpha=.12; ctx.fillStyle='#000'; ctx.fillRect(0,(dy?S:0),W*S,2*S); ctx.globalAlpha=1;
  }
  const avatar1 = makeAvatar($('#avatar1'), '#ff5ca8');
  const avatar2 = makeAvatar($('#avatar2'), '#68c7ff');

  /*
    Встроенные версии игр.  Чтобы обеспечить работу при открытии файла
    напрямую (file://) без сервера, мы дублируем реализацию модулей
    Pong и Runner прямо здесь.  Когда сайт работает по HTTP, эти
    встроенные версии не нужны — хаб пытается загрузить игры из
    каталога games/<slug>/module.js и использует их.  Но если загрузка
    через <script src> завершилась неудачей (например, из-за
    ограничений браузера на file://), встраиваемые варианты спасают.
  */
  const games = {
    pong: {
      manifest: { slug:'pong', name:'Pong', caption:'Классика 1v1', icon:'🏓', version:'1.0.0', players:2 },
      async mount(root, context) {
        // реализация аналогична games/pong/module.js
        const container = document.createElement('div');
        container.className = 'game-pong';
        container.style.position = 'relative';
        container.style.width = '100%';
        container.style.height = '100%';
        root.innerHTML = '';
        root.appendChild(container);
        const canvas = document.createElement('canvas');
        canvas.width = 160;
        canvas.height = 100;
        canvas.className = 'pixel';
        canvas.style.width = canvas.width + 'px';
        canvas.style.height = canvas.height + 'px';
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        const ro = new ResizeObserver(()=>{
          const w = container.clientWidth, h = container.clientHeight;
          const scale = Math.max(1, Math.floor(Math.min(w/canvas.width, h/canvas.height)));
          canvas.style.width = canvas.width*scale+'px';
          canvas.style.height = canvas.height*scale+'px';
        });
        ro.observe(container);
        const scoreEl = document.createElement('div');
        scoreEl.style.position = 'absolute';
        scoreEl.style.top = '6px';
        scoreEl.style.left = '50%';
        scoreEl.style.transform = 'translateX(-50%)';
        scoreEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--ink');
        scoreEl.style.font = '14px ui-monospace';
        scoreEl.style.userSelect = 'none';
        container.appendChild(scoreEl);
        const backBtn = document.createElement('button');
        backBtn.textContent = 'Назад';
        backBtn.className = 'btn ghost';
        backBtn.style.position = 'absolute';
        backBtn.style.bottom = '8px';
        backBtn.style.left = '8px';
        backBtn.onclick = () => { location.hash = ''; };
        container.appendChild(backBtn);
        const width = canvas.width;
        const height = canvas.height;
        const paddleW = 2;
        const paddleH = 16;
        const ballSize = 2;
        let p1 = { y: height/2 - paddleH/2, score: 0 };
        let p2 = { y: height/2 - paddleH/2, score: 0 };
        let ball = { x: width/2, y: height/2, vx: 1.8, vy: 1.2 };
        let running = true;
        let pointerY = null;
        const keys = {};
        function onPointer(e){ e.preventDefault(); const rect=canvas.getBoundingClientRect(); const sy=(e.clientY-rect.top)/rect.height; pointerY = sy*height; }
        canvas.addEventListener('pointermove', onPointer, {passive:false});
        canvas.addEventListener('pointerdown', onPointer, {passive:false});
        function onKeyDown(e){ keys[e.key.toLowerCase()] = true; }
        function onKeyUp(e){ keys[e.key.toLowerCase()] = false; }
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        function resetBall(){ ball.x = width/2; ball.y = height/2; ball.vx = (Math.random()>0.5?1:-1)*1.8; ball.vy = (Math.random()-0.5)*2; }
        function update(){
          if(pointerY !== null){ const target = pointerY - paddleH/2; p1.y += (target - p1.y)*0.2; }
          else{ if(keys['w']) p1.y -= 2; if(keys['s']) p1.y += 2; }
          if(keys['arrowup'] || keys['arrowdown']){ if(keys['arrowup']) p2.y -= 2; if(keys['arrowdown']) p2.y += 2; }
          else{ const target = ball.y - paddleH/2; p2.y += (target - p2.y)*0.05; }
          p1.y = Math.max(0, Math.min(height - paddleH, p1.y)); p2.y = Math.max(0, Math.min(height - paddleH, p2.y));
          ball.x += ball.vx; ball.y += ball.vy;
          if(ball.y <= 0 || ball.y >= height - ballSize){ ball.vy *= -1; ball.y = Math.max(0, Math.min(height-ballSize, ball.y)); }
          if(ball.x <= paddleW && ball.y + ballSize > p1.y && ball.y < p1.y + paddleH){ ball.vx = Math.abs(ball.vx); const impact=(ball.y+ballSize/2-(p1.y+paddleH/2))/(paddleH/2); ball.vy = impact*1.5; }
          if(ball.x + ballSize >= width - paddleW && ball.y + ballSize > p2.y && ball.y < p2.y + paddleH){ ball.vx = -Math.abs(ball.vx); const impact=(ball.y+ballSize/2-(p2.y+paddleH/2))/(paddleH/2); ball.vy = impact*1.5; }
          if(ball.x < -ballSize){ p2.score++; resetBall(); }
          if(ball.x > width + ballSize){ p1.score++; resetBall(); }
        }
        function render(){
          const styles = getComputedStyle(document.documentElement);
          const odd = styles.getPropertyValue('--grid-odd').trim();
          const even = styles.getPropertyValue('--grid-even').trim();
          const highlight = styles.getPropertyValue('--highlight');
          for(let y=0; y<height; y+=16){ for(let x=0; x<width; x+=16){ ctx.fillStyle = ((x+y)/16 % 2 === 0) ? odd : even; ctx.fillRect(x,y,16,16); } }
          ctx.fillStyle = highlight; for(let y=0;y<height;y+=6) ctx.fillRect(width/2-1,y,2,3);
          ctx.fillStyle = '#ff77bd'; ctx.fillRect(0,p1.y,paddleW,paddleH);
          ctx.fillStyle = '#68c7ff'; ctx.fillRect(width-paddleW,p2.y,paddleW,paddleH);
          ctx.fillStyle = '#ffd166'; ctx.fillRect(ball.x, ball.y, ballSize, ballSize);
          scoreEl.textContent = `${p1.score} : ${p2.score}`;
        }
        let animId;
        function loop(){ update(); render(); animId = requestAnimationFrame(loop); }
        loop();
        return { unmount(){ cancelAnimationFrame(animId); canvas.removeEventListener('pointermove', onPointer); canvas.removeEventListener('pointerdown', onPointer); window.removeEventListener('keydown', onKeyDown); window.removeEventListener('keyup', onKeyUp); ro.disconnect(); if(container.parentNode===root) root.removeChild(container); } };
      }
    },
    runner: {
      manifest: { slug:'runner', name:'Runner', caption:'Прыгай и беги', icon:'🏃', version:'1.0.0', players:1 },
      async mount(root, context){
        const container = document.createElement('div');
        container.className = 'game-runner'; container.style.position = 'relative'; container.style.width='100%'; container.style.height='100%'; root.innerHTML=''; root.appendChild(container);
        const canvas = document.createElement('canvas'); canvas.width=160; canvas.height=90; canvas.className='pixel'; canvas.style.width=canvas.width+'px'; canvas.style.height=canvas.height+'px'; container.appendChild(canvas);
        const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
        const ro = new ResizeObserver(()=>{ const w=container.clientWidth,h=container.clientHeight; const scale=Math.max(1,Math.floor(Math.min(w/canvas.width,h/canvas.height))); canvas.style.width=canvas.width*scale+'px'; canvas.style.height=canvas.height*scale+'px'; }); ro.observe(container);
        const scoreEl = document.createElement('div'); scoreEl.style.position='absolute'; scoreEl.style.top='6px'; scoreEl.style.left='8px'; scoreEl.style.color=getComputedStyle(document.documentElement).getPropertyValue('--ink'); scoreEl.style.font='14px ui-monospace'; scoreEl.style.userSelect='none'; container.appendChild(scoreEl);
        const backBtn = document.createElement('button'); backBtn.textContent='Назад'; backBtn.className='btn ghost'; backBtn.style.position='absolute'; backBtn.style.bottom='8px'; backBtn.style.left='8px'; backBtn.onclick=() => { location.hash=''; }; container.appendChild(backBtn);
        const width = canvas.width; const height = canvas.height; const groundY = height - 10; const gravity=0.2;
        const player = { x:20, y: groundY - 8, vy:0, w:8, h:8, jumping:false };
        let obstacles = []; let spawnTimer=0; let score=0; let running=true; let gameOver=false;
        function resetGame(){ player.y=groundY-player.h; player.vy=0; player.jumping=false; obstacles=[]; spawnTimer=0; score=0; gameOver=false; running=true; }
        function jump(){ if(!player.jumping && !gameOver){ player.vy = -4.2; player.jumping = true; } if(gameOver){ resetGame(); } }
        function onPointer(e){ e.preventDefault(); jump(); }
        function onKey(e){ if(e.key === ' '){ e.preventDefault(); jump(); } }
        canvas.addEventListener('pointerdown', onPointer, {passive:false});
        window.addEventListener('keydown', onKey);
        function update(){ if(!running) return; player.vy += gravity; player.y += player.vy; if(player.y >= groundY-player.h){ player.y = groundY-player.h; player.vy=0; player.jumping=false; } spawnTimer--; if(spawnTimer <= 0){ const obsH = 12 + Math.floor(Math.random()*10); obstacles.push({ x: width, y: groundY - obsH, w:6, h:obsH }); spawnTimer = 80 + Math.random()*60; } for(let i=obstacles.length-1; i>=0; i--){ const o=obstacles[i]; o.x -= 1.8; if(!gameOver && o.x < player.x + player.w && o.x + o.w > player.x && o.y < player.y + player.h && o.y + o.h > player.y){ gameOver = true; running=false; if(score>best){ best=score; context && context.store && context.store.set('games.runner.best', best); } } if(o.x + o.w < 0){ obstacles.splice(i,1); if(!gameOver) score++; } } }
        function drawPlayer(){ const px=(x,y,s,c)=>{ ctx.fillStyle=c; ctx.fillRect(x*s,y*s,s,s); }; const s=1; const offX=Math.floor(player.x); const offY=Math.floor(player.y); // тело
          px(offX+1, offY+3, s, '#ff77bd'); px(offX+2, offY+3, s, '#ff77bd'); px(offX+1, offY+4, s, '#ff77bd'); px(offX+2, offY+4, s, '#ff77bd'); px(offX+1, offY+5, s, '#ff77bd'); px(offX+2, offY+5, s, '#ff77bd'); // голова
          px(offX+1, offY+1, s, '#ffd166'); px(offX+2, offY+1, s, '#ffd166'); px(offX+1, offY+2, s, '#ffd166'); px(offX+2, offY+2, s, '#ffd166'); // глаза
          px(offX+1, offY+2, s, '#10131e'); px(offX+2, offY+2, s, '#10131e'); }
        function render(){ const styles=getComputedStyle(document.documentElement); const odd=styles.getPropertyValue('--grid-odd').trim(); const even=styles.getPropertyValue('--grid-even').trim(); const highlight=styles.getPropertyValue('--highlight'); for(let y=0;y<height;y+=16){ for(let x=0;x<width;x+=16){ ctx.fillStyle = ((x+y)/16 % 2 === 0) ? odd : even; ctx.fillRect(x,y,16,16); } } ctx.fillStyle=highlight; ctx.fillRect(0, groundY, width, 1); drawPlayer(); ctx.fillStyle='#ff6b6b'; obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h)); scoreEl.textContent = gameOver ? `Game Over — счет: ${score} (лучший: ${best})` : `Очки: ${score}`; }
        let animId; let best = context && context.store ? context.store.get('games.runner.best',0) : 0; function loop(){ update(); render(); animId = requestAnimationFrame(loop); } loop();
        return { unmount(){ running=false; cancelAnimationFrame(animId); canvas.removeEventListener('pointerdown', onPointer); window.removeEventListener('keydown', onKey); ro.disconnect(); if(container.parentNode===root) root.removeChild(container); } };
      }
    }
  };

  // Роутинг: загрузка игрового модуля по хэшу без dynamic import
  let currentGame = null;
  async function loadGameModule(slug) {
    // Если модуль уже зарегистрирован, возвращаем его
    if(window.__DeepFlyGames && window.__DeepFlyGames[slug]) {
      return window.__DeepFlyGames[slug];
    }
    // Иначе создаём тег script и загружаем файл
    // Если открыто из файловой системы (file://), браузер не позволит
    // подключать соседние .js файлы как скрипты.  В этом режиме сразу
    // возвращаем встроенную игру, если она есть.
    if (location.protocol === 'file:' && games && games[slug]) {
      return games[slug];
    }
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = `./games/${slug}/module.js`;
      // Успешная загрузка: проверяем, зарегистрирован ли модуль
      script.onload = () => {
        if (window.__DeepFlyGames && window.__DeepFlyGames[slug]) {
          resolve(window.__DeepFlyGames[slug]);
        } else if (games && games[slug]) {
          // Файл загружен, но модуль не зарегистрировался: используем встроенную игру
          resolve(games[slug]);
        } else {
          // Нет ни внешнего, ни встроенного модуля
          reject(new Error(`Модуль ${slug} не зарегистрирован`));
        }
      };
      // Ошибка загрузки: пытаемся использовать встроенный вариант
      script.onerror = () => {
        // Удаляем тег, чтобы не засорять head
        if (script.parentNode) script.parentNode.removeChild(script);
        if (games && games[slug]) {
          resolve(games[slug]);
        } else {
          reject(new Error(`Не удалось загрузить файл games/${slug}/module.js`));
        }
      };
      document.head.appendChild(script);
    });
  }
  async function loadFromHash(){
    const m = location.hash.match(/game=([\w-]+)/);
    if(!m){
      if(currentGame && currentGame.unmount) currentGame.unmount();
      currentGame = null;
      $('#preview').style.display='block';
      $('#menu').style.display='grid';
      startPreview();
      const firstCard = $('#menu .card'); if(firstCard) firstCard.focus();
      return;
    }
    const slug = m[1];
    try {
      let mod;
      // Всегда сначала пробуем встроенную игру.  Это гарантирует
      // работу из локальной файловой системы, где загрузка внешних
      // модулей запрещена.  Если встроенного варианта нет, пытаемся
      // загрузить модуль из каталога games/<slug>/.
      if (games && games[slug]) {
        mod = games[slug];
      } else {
        mod = await loadGameModule(slug);
      }
      if(currentGame && currentGame.unmount) currentGame.unmount();
      currentGame = await mod.mount($('#scenePanel'), getContext());
      stopPreview();
      $('#preview').style.display='none';
      $('#menu').style.display='none';
    } catch(err) {
      flash(`Не удалось загрузить игру «${slug}». Убедитесь, что папка games/${slug}/module.js существует.`);
      if(currentGame && currentGame.unmount) currentGame.unmount();
      currentGame = null;
      $('#preview').style.display='block';
      $('#menu').style.display='grid';
      startPreview();
      const firstCard = $('#menu .card'); if(firstCard) firstCard.focus();
    }
  }
  window.addEventListener('hashchange', loadFromHash);
  loadFromHash();
  
  // Контекст, передаваемый в игры
  function getContext(){
    return {
      version: HUB_VERSION,
      bus,
      theme,
      store,
      ui:{ flash },
      input: {
        // упрощённый ввод: подписка на клавиши
        on(type, handler){ window.addEventListener(type, handler); },
        off(type, handler){ window.removeEventListener(type, handler); }
      },
      net:{ rest: async ()=>{ throw new Error('REST не настроен'); }, rt:{ connect:()=>({ publish(){}, subscribe(){}, close(){} }) } },
      root: $('#scenePanel')
    };
  }

  // Профиль и настройки
  const colors = ['#ff5ca8','#68c7ff','#ffd166'];
  let profile = {
    id: store.get('profile.id', Date.now()),
    nickname: store.get('profile.nickname','Игрок'),
    avatar: store.get('profile.avatar',0)
  };
  store.set('profile.id', profile.id);
  $('#playerName').textContent = profile.nickname;
  avatar1.setTint(colors[profile.avatar]);
  const avatarEdit = makeAvatar($('#avatarEdit'), colors[profile.avatar]);

  let avatarDlg=null;
  function openAvatarPanel(opener){
    $('#nickInput').value = profile.nickname;
    avatarEdit.setTint(colors[profile.avatar]);
    avatarDlg = openDialog('#avatarDialog', opener);
  }
  $('#avatarPrev').onclick = ()=>{ profile.avatar=(profile.avatar+colors.length-1)%colors.length; avatarEdit.setTint(colors[profile.avatar]); };
  $('#avatarNext').onclick = ()=>{ profile.avatar=(profile.avatar+1)%colors.length; avatarEdit.setTint(colors[profile.avatar]); };
  $('#avatarSave').onclick = ()=>{
    profile.nickname = $('#nickInput').value.trim() || 'Игрок';
    store.set('profile.nickname', profile.nickname);
    store.set('profile.avatar', profile.avatar);
    $('#playerName').textContent = profile.nickname;
    avatar1.setTint(colors[profile.avatar]);
    avatarDlg && avatarDlg.close();
  };
  $('#avatarCancel').onclick = ()=>{ avatarDlg && avatarDlg.close(); };
  $('#avatarClose').onclick = ()=>{ avatarDlg && avatarDlg.close(); };
  $('#profileSave').onclick = ()=> openAvatarPanel($('#profileSave'));
  $('#profileReset').onclick = () => {
    store.del('profile.nickname');
    store.del('profile.avatar');
    profile.nickname = 'Игрок';
    profile.avatar = 0;
    $('#playerName').textContent = profile.nickname;
    avatar1.setTint(colors[0]);
  };

  settings.mute = store.get('settings.mute', false);
  settings.vfx = store.get('settings.vfx', true);
  settings.theme = store.get('settings.theme', 'dark');
  theme.apply(settings.theme);
  $('#muteToggle').checked = settings.mute;
  $('#vfxToggle').checked = settings.vfx;
  $('#themeAltToggle').checked = settings.theme === 'alt';
  let settingsDlg=null;
  $('#settingsSave').onclick = ()=>{
    settings.mute = $('#muteToggle').checked;
    settings.vfx = $('#vfxToggle').checked;
    settings.theme = $('#themeAltToggle').checked ? 'alt' : 'dark';
    store.set('settings.mute', settings.mute);
    store.set('settings.vfx', settings.vfx);
    store.set('settings.theme', settings.theme);
    theme.apply(settings.theme);
    settingsDlg && settingsDlg.close();
  };
  $('#settingsCancel').onclick = ()=>{ settingsDlg && settingsDlg.close(); };
  $('#settingsClose').onclick = ()=>{ settingsDlg && settingsDlg.close(); };

  // Меню игр
  function buildMenu(){
    const menu = $('#menu');
    menu.innerHTML='';
    const slugs=['pong','runner'];
    slugs.forEach(slug=>{
      const man = (games[slug]&&games[slug].manifest)||{slug};
      const btn=document.createElement('button');
      btn.className='card';
      btn.tabIndex=0;
      btn.dataset.slug=slug;
      btn.innerHTML=`<div class="icon">${man.icon||''}</div><div>${man.name||slug}</div><small>${man.caption||''}</small>`;
      btn.addEventListener('click',()=>{ location.hash=`game=${slug}`; });
      btn.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); location.hash=`game=${slug}`; }});
      btn.addEventListener('focus',()=>{ btn.scrollIntoView({block:'nearest',inline:'center'}); });
      btn.setAttribute('aria-label', man.name||slug);
      menu.appendChild(btn);
    });
  }
  buildMenu();
  $('#menu').addEventListener('keydown', e=>{
    const cards = Array.from($('#menu').querySelectorAll('.card'));
    const idx = cards.indexOf(document.activeElement);
    if(e.key==='ArrowRight'){ const n=Math.min(cards.length-1, idx+1); cards[n].focus(); e.preventDefault(); }
    if(e.key==='ArrowLeft'){ const n=Math.max(0, idx-1); cards[n].focus(); e.preventDefault(); }
  });

  // Заголовок
  $('#openGames').onclick = () => { location.hash = ''; };
  $('#openSettings').onclick = () => { $('#muteToggle').checked = settings.mute; $('#vfxToggle').checked = settings.vfx; $('#themeAltToggle').checked = settings.theme==='alt'; settingsDlg = openDialog('#settingsDialog', $('#openSettings')); };
  $('#openAvatar').onclick = () => { openAvatarPanel($('#openAvatar')); };

  </script>
</body>
</html>